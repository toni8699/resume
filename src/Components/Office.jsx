/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/chair/scene.gltf --transform
Files: public/chair/scene.gltf [11.36KB] > /Users/tony/Desktop/resume/scene-transformed.glb [1.88MB] (-16421%)
Author: eucocker (https://sketchfab.com/eucocker)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/chair-c5f49f97856c461a8192fb950ce23540
Title: Chair
*/

import React, {useEffect, useRef} from 'react'
import { useGLTF } from '@react-three/drei'
import {useFrame, useThree} from "@react-three/fiber";

const Office = (props) => {
    // const RoomRef = useRef();
    // // const [gl,viewport] = useThree();
    // const lastX = useRef(0);
    // const rotationSpeed=useRef(0);
    // const dampingFactor=0.75;
    // // const handleMouseDown=(e)=>{
    //     e.stopPropagation();
    //     e.preventDefault();
    //     setIsRotating(true);
    //     const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    //     lastX.current = clientX;
    // }
    // const handleMouseUp=(e)=>{
    //     e.stopPropagation();
    //     e.preventDefault();
    //     setIsRotating(false);
    // }
    // const handleMouseMove=(e)=>{
    //     e.stopPropagation();
    //     e.preventDefault();
    //     if (isRotating){
    //         const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    //         const deltaX = (clientX - lastX.current)/viewport.width;
    //         rotationSpeed.current.rotation.y+= Math.PI*deltaX*0.01;
    //         lastX.current = clientX;
    //     }
    // }
    // useFrame(() => {
    //
    //     // If not rotating, apply damping to slow down the rotation (smoothly)
    //     if (!isRotating) {
    //         // Apply damping factor
    //         rotationSpeed.current *= dampingFactor;
    //
    //         // Stop rotation when speed is very small
    //         if (Math.abs(rotationSpeed.current) < 0.001) {
    //             rotationSpeed.current = 0;
    //         }
    //         RoomRef.current.rotation.y += rotationSpeed.current;
    //     } else {
    //         // When rotating, determine the current stage based on island's orientation
    //         const rotation = RoomRef.current.rotation.y;
    //
    //         /**
    //          * Normalize the rotation value to ensure it stays within the range [0, 2 * Math.PI].
    //          * The goal is to ensure that the rotation value remains within a specific range to
    //          * prevent potential issues with very large or negative rotation values.
    //          *  Here's a step-by-step explanation of what this code does:
    //          *  1. rotation % (2 * Math.PI) calculates the remainder of the rotation value when divided
    //          *     by 2 * Math.PI. This essentially wraps the rotation value around once it reaches a
    //          *     full circle (360 degrees) so that it stays within the range of 0 to 2 * Math.PI.
    //          *  2. (rotation % (2 * Math.PI)) + 2 * Math.PI adds 2 * Math.PI to the result from step 1.
    //          *     This is done to ensure that the value remains positive and within the range of
    //          *     0 to 2 * Math.PI even if it was negative after the modulo operation in step 1.
    //          *  3. Finally, ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI) applies another
    //          *     modulo operation to the value obtained in step 2. This step guarantees that the value
    //          *     always stays within the range of 0 to 2 * Math.PI, which is equivalent to a full
    //          *     circle in radians.
    //          */
    //         const normalizedRotation =
    //             ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    //
    //         // Set the current stage based on the island's orientation
    //         switch (true) {
    //             case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
    //                 setCurrentStage(4);
    //                 break;
    //             case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
    //                 setCurrentStage(3);
    //                 break;
    //             case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
    //                 setCurrentStage(2);
    //                 break;
    //             case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
    //                 setCurrentStage(1);
    //                 break;
    //             default:
    //                 setCurrentStage(null);
    //         }
    //     }
    // });
    // useEffect(() => {
    //     const canvas = gl.domElement;
    //
    //     canvas.addEventListener('mousemove',handleMouseMove);
    //     canvas.addEventListener('mouseup',handleMouseUp);
    //     canvas.addEventListener('touchmove',handleMouseMove);
    //     return () => {
    //         canvas.removeEventListener('mousemove',handleMouseMove);
    //         canvas.removeEventListener('mouseup',handleMouseUp);
    //         canvas.removeEventListener('touchmove',handleMouseMove);
    //     };
    // }, [gl,handleMouseDown(),handleMouseMove(),handleMouseUp()]);

    // const handleKeyDown=(e)=>{
    //     if (e.key === "ArrowLeft"){
    //         setIsRotating(true);
    //         RoomRef.current.rotation.y+=0.01;
    //     }
    //     if (e.key === "ArrowRight"){
    //         setIsRotating(true);
    //         RoomRef.current.rotation.y-=0.01;
    //     }
    // }
    // const handleKeyUp=(e)=>{
    //     if (e.key === "ArrowLeft" || e.key === "ArrowRight"){
    //         setIsRotating(false);
    //     }
    // }
    // useEffect(() => {
    //     document.addEventListener('keydown',handleKeyDown);
    //     document.addEventListener('keyup',handleKeyUp);
    //     return () => {
    //         document.removeEventListener('keydown',handleKeyDown);
    //         document.removeEventListener('keyup',handleKeyUp);
    //     };
    // }, [gl,handleKeyDown(),handleKeyUp()]);

    const { nodes, materials } = useGLTF('/late_night_office/scene.gltf')
    return (
        <group {...props} dispose={null}>
            <group scale={0.01}>
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Room_ROOM_Mat_0.geometry}
                    material={materials.ROOM_Mat}
                    position={[-19.137, 168.453, -33.842]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Window_WINDOW_Mat_0.geometry}
                    material={materials.WINDOW_Mat}
                    position={[-19.521, 166.582, -28.049]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Boxes_BOXES_Mat_0.geometry}
                    material={materials.BOXES_Mat}
                    position={[9.951, 142.012, 2.406]}
                    rotation={[-Math.PI / 2, 0, 0]}
                    scale={100}
                />
            </group>
        </group>
    )
}

useGLTF.preload('/late_night_office/scene.gltf')
export default Office